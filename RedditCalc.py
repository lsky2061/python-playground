def anchor(k,f):
    #k is total karma generated by a post = u - d
    #f is fraction upvoted = u/(u+d)
    if (f==0.5 and k==0):
        print('We have a case where the upvotes and downvotes are equal. Unfortunately, that is all we can say.')
        return [-3,-3]
    f_low = f-0.005
    #Need to divide into 3 cases (f> 50%, f<50%, f= 50%)
    d = k*((f_low-1)/(1-2*f_low)) # calculated number of downvotes
    u = d + k
    u_int = 0
    d_int = 0
    ud_out = [-1,-1]
    print('Raw calculations: u = {0:.3f}, d={1:.3f} \n'.format(u,d))
    #These u and d values will usually be non-integers, so we find out which integers are closest
    if u< 0 or d < 0:
        print('This combination of values is not possible. If the total points is negative, that means the fraction of upvotes must be less than 50% and vice versa.')
        return [-2,-2]
    #print('Upvotes, Downvotes, Karma, Fraction, Rounded')
    #f_low = f - 0.005
    for ua in [0,1]:
        for da in [0,1]:
            u_int = int(u) + ua #Check the lower and upper nearest integers
            d_int = int(d) + da
            f_fromint = u_int/(u_int+d_int)
            if (u_int - d_int)==k and k <= u_int and abs(f - f_fromint)<=0.005:
                
                #print('Nearest integers: u = {0}, d={1}, k={2}, f={3}'.format(u_int,d_int,u_int-d_int,u_int/(u_int+d_int)))
                #print('{0:7d}, {1:9d}, {2:5d}, {3:.6f}, {4:.0f}%'
                 #     .format(int(u_int),int(d_int), int(u_int-d_int),f_fromint,
                  #            (u_int/(u_int+d_int))*100))
                if(ud_out[0] == -1  or u_int<ud_out[0]): 
                    ud_out =[u_int,d_int]
                   
    return ud_out
              
               
                
def RScan(k,f):
    #Call function to find minimum u and d values
    if (f>1 and f<=100): f = f/100
    ud_in = anchor(k,f)
    u_int = ud_in[0]
    d_int = ud_in[1] 
    if(u_int==-1): #Error Checking
        print('No combination matching these values exists. Possible vote "fuzzing"!')
    elif(u_int<1):
        pass
    else:
        f_fromint = u_int/(u_int+d_int)
        print('Upvotes, Downvotes, Karma, Fraction, Rounded')
        print('{0:7d}, {1:9d}, {2:5d}, {3:.6f}, {4:.0f}%'
                  .format(u_int+1,d_int+1, int(u_int-d_int),
                          (u_int+1)/(u_int+d_int+2),
                          ((u_int+1)/(u_int+d_int+2))*100))
        print('-------------------------------------------')
        
        while (f_fromint > f- 0.005) and (f_fromint< f + 0.005): #Keep the output within the bounded range
            print('{0:7d}, {1:9d}, {2:5d}, {3:.6f}, {4:.0f}%'
                          .format(int(u_int),int(d_int), int(u_int-d_int),f_fromint,
                                  (u_int/(u_int+d_int))*100))
            u_int -= 1
            d_int -= 1
            f_fromint = u_int/(u_int+d_int)
        #Print one "out of bounds" line to ensure we have all possible values.
        print('-------------------------------------------')
        print('{0:7d}, {1:9d}, {2:5d}, {3:.6f}, {4:.0f}%'
                          .format(int(u_int),int(d_int), int(u_int-d_int),f_fromint,
                                  (u_int/(u_int+d_int))*100))
            
           
            
            
    


                

def RV(k,f):
    #k is total karma generated by a post = u - d
    #f is fraction upvoted = u/(u+d)
    range_low = 0
    range_up = 1
    result = []
    if f == 0.5:
        if k == 0:
            print('We have a case where the upvotes and downvotes are equal. Unfortunately, that is all we can say.')
            return -1
        else:
            if k< 0: f = 0.499999
            else: f = 0.500001
            print('If the total karma is not zero, the fraction must be rounded to 50%. In order to keep divide by zero errors from occuring, resetting f to {0:.2f}'.format(f*100))
    d = k*((f-1)/(1-2*f)) # calculated number of downvotes
    u = d + k
    u_int = 0
    d_int = 0
    possibilites = 0
    print('Raw calculations: u = {0:.3f}, d={1:.3f} \n'.format(u,d))
    #These u and d values will usually be non-integers, so we find out which integers are closest
    if u< 0 or d < 0:
        print('This combination of values is not possible. If the total points is negative, that means the fraction of upvotes must be less than 50% and vice versa.')
        return -2
    range_est = int(int(u)*0.01)
    #range_est = int(u) - 2
    if(range_est > range_up):
        range_low = 0-range_est
        range_up = range_est + 2
    print('Upvotes, Downvotes, Karma, Fraction, Rounded')
    for ua in range(range_low,range_up+1):
        for da in range(range_low,range_up+1):
           # print('Checking u +',ua,', d + ',da)
            u_int = int(u) + ua #Check the lower and upper nearest integers
            d_int = int(d) + da
            f_fromint = u_int/(u_int+d_int)
            if (u_int - d_int)==k and k <= u_int and abs(f - f_fromint)<=0.005:
                #print('Nearest integers: u = {0}, d={1}, k={2}, f={3}'.format(u_int,d_int,u_int-d_int,u_int/(u_int+d_int)))
                print('{0:7d}, {1:9d}, {2:5d}, {3:.6f}, {4:.0f}%'
                      .format(int(u_int),int(d_int), int(u_int-d_int),f_fromint,
                              (u_int/(u_int+d_int))*100))
                possibilites += 1
        
